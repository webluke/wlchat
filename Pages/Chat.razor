@page "/chat"
@page "/chat/{ThreadId:int}"
@inject ChatService ChatService
@inject ModelService ModelService
@inject AuthenticationStateProvider AuthStateProvider
@using Auth0.AspNetCore.Authentication
@inject NavigationManager NavigationManager
@inject IJSRuntime JS

<div class="chat-app">
    <div class="chat-title">@(IsNewThread ? "New Chat" : $"{ThreadTitle}")</div>
    <div class="chat-container">
    @if (!IsNewThread)
    {
        @foreach (var msg in ThreadMessages)
        {
            <div class="chat-message from-me">
                <div class="avatar">🤔</div>
                <div class="message-bubble">
                    <div class="message-text">
                        @((MarkupString)MarkdownService.Parse(msg.Prompt))
                    </div>
                </div>
            </div>
            <div class="chat-message from-them">
                <div class="avatar">🤖</div>
                <div class="message-bubble">
                    <div class="message-text">
                        @((MarkupString)MarkdownService.Parse(msg.Response))
                    </div>
                    <div class="message-time">@msg.Model - @msg.CreatedAt</div>
                </div>
            </div>
        }
        @if (IsLoading)
        {
            <div class="chat-message from-me">
                <div class="avatar">🤔</div>
                <div class="message-bubble">
                    <div class="message-text">
                            @((MarkupString)MarkdownService.Parse(UserInput))
                    </div>
                </div>
            </div>
            <div class="chat-message from-them">
                <div class="avatar">🤖</div>
                <div class="message-bubble">
                    <div class="message-text">
                        @CurrentResponse
                    </div>
                    <div class="message-time">loading...</div>
                </div>
            </div>
        }
    }
    </div>
    <div class="chat-input-area">
        <textarea class="chat-input" placeholder="" rows="5" @bind="UserInput"></textarea>
        <div class="input-row">
        <select id="userSelect" @bind="SelectedModel">
            @foreach (var model in AvailableModels)
            {
                <option value="@model.Id">@model.Id</option>
            }
        </select>
        <button class="send-btn" title="Send" @onclick="SendPrompt" disabled="@IsLoading">
                @if (IsLoading)
                {
                    <span class="emoji">🔥</span>
                } else
                {
                    <span class="emoji">🚀</span>
                }
            </button>
        </div>
    </div>
</div>
<script>
    window.scrollChatToBottom = function () {
      var chatContainer = document.querySelector('.chat-container');
      if (chatContainer) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    }
</script>
@code {
    [Parameter] public int? ThreadId { get; set; }
    private string UserInput;
    private List<ModelInfo> AvailableModels = new();
    private string SelectedModel;
    private string UserId;
    private string ThreadTitle;
    private bool IsNewThread => !ThreadId.HasValue;
    private List<ChatHistory> ThreadMessages = new();
    private bool IsLoading = false;
    private ChatHistory CurrentMessage = new ChatHistory();

    // Streaming output
    private string CurrentResponse = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadUserIdAsync();
        await LoadModelsAsync();
        await LoadThreadAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadThreadAsync();
    }

    private async Task LoadUserIdAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        UserId = user.FindFirst(c =>
            c.Type == "sub" ||
            c.Type == "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier"
        )?.Value;
    }

    private async Task LoadModelsAsync()
    {
        AvailableModels = await ModelService.GetAvailableModelsAsync();
        SelectedModel = AvailableModels.FirstOrDefault()?.Id;
    }

    private async Task LoadThreadAsync()
    {
        if (ThreadId.HasValue && !string.IsNullOrEmpty(UserId))
        {
            ThreadMessages = await ChatService.GetMessagesForThreadAsync(ThreadId.Value);
            var thread = (await ChatService.GetThreadsForUserAsync(UserId))
                .FirstOrDefault(t => t.Id == ThreadId.Value);
            ThreadTitle = thread?.Title ?? $"Thread {ThreadId}";
            CurrentMessage = ThreadMessages.LastOrDefault() ?? new ChatHistory();
        }
        else
        {
            ThreadMessages = new List<ChatHistory>();
            ThreadTitle = null;
            CurrentMessage = new ChatHistory();
        }
        StateHasChanged();
    }

    private List<string> OutputChunks = new();

    private async Task SendPrompt()
    {
        if (String.IsNullOrEmpty(UserInput)) { return; }
        OutputChunks.Clear();
        CurrentResponse = "";
        IsLoading = true;
        StateHasChanged();

        int threadId = ThreadId ?? 0;

        if (IsNewThread)
        {
            ThreadTitle = UserInput.Length > 40 ? UserInput.Substring(0, 40) + "..." : UserInput;
            threadId = await ChatService.CreateThreadAsync(UserId, ThreadTitle);

            await foreach (var chunk in ChatService.StreamResponseAsync(threadId, UserInput, SelectedModel))
            {
                OutputChunks.Add(chunk);
                CurrentResponse += chunk;
                StateHasChanged();
            }

            CurrentResponse = CurrentResponse
                .Replace("[DONE]", "", StringComparison.OrdinalIgnoreCase)
                .Replace("\n\n", "\n")
                .Trim();

            await ChatService.SaveChatAsync(threadId, UserId, UserInput, CurrentResponse, SelectedModel);

            // After saving, clear streaming state and load the latest message from history
            ThreadMessages = await ChatService.GetMessagesForThreadAsync(threadId);
            OutputChunks.Clear();
            CurrentResponse = ThreadMessages.LastOrDefault()?.Response ?? "";
            IsLoading = false;
            UserInput = "";
            StateHasChanged();

            NavigationManager.NavigateTo($"/chat/{threadId}", forceLoad: true);
            return;
        }

        // Existing thread
        await foreach (var chunk in ChatService.StreamResponseAsync(threadId, UserInput, SelectedModel))
        {
            OutputChunks.Add(chunk);
            CurrentResponse += chunk;
            StateHasChanged();
        }

        CurrentResponse = CurrentResponse
            .Replace("[DONE]", "", StringComparison.OrdinalIgnoreCase)
            .Replace("\n\n", "\n")
            .Trim();

        await ChatService.SaveChatAsync(threadId, UserId, UserInput, CurrentResponse, SelectedModel);

        // After saving, clear streaming state and load the latest message from history
        ThreadMessages = await ChatService.GetMessagesForThreadAsync(threadId);
        OutputChunks.Clear();
        CurrentResponse = ThreadMessages.LastOrDefault()?.Response ?? "";
        IsLoading = false;
        UserInput = "";
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("scrollChatToBottom");
        await JS.InvokeVoidAsync("highlightCode");
    }
}